#+TITLE: Rambles
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://cdn.rwest.io/css/page.css"/>
#+DESCRIPTION: ideas, hacks, experiments and reflections.
#+CREATED: [2021-07-07]

* Conky
:PROPERTIES:
:ID:       ee68a953-f9b3-447d-a531-ef301ca1e0d9
:END:
[[https://github.com/brndnmtthws/conky][Conky]] is a lightweight system monitor program for X that generates nice little desktop
widgets from Lua config files. I recently started using it, and kinda like it. The
config is a bit tricky but it is a powerful system I want to know more about.

Here's a few widgets I set up - they stay on the desktop behind all my other windows, so
when I want to see some quick stats I can just switch to an empty tag in AwesomeWM
(which is also configured via Lua).

Using conky is very easy. It takes a few flags to run in the background smoothly and a
config file as input.

As a shell script:
#+begin_src shell
#!/bin/sh
conky -bdc ~/.config/conky/conky-l1.lua &
conky -bdc ~/.config/conky/conky-l2.lua &
#+end_src

Or in Rust:
#+begin_src rust
use cmd_lib::{run_cmd, CmdResult};

/// start conky service in background
#[cfg(unix)]
pub fn conky(cfg: &str) -> CmdResult {
  Ok(run_cmd!(conky  -qbdc "$cfg" '&')?)
}
#+end_src

- screenshot
  #+caption: conky desktop widgets
  #+attr_html: :width 600
  [[https://cdn.rwest.io/img/conky_desktop.png]]

Next thing I want to do is mess with [[https://github.com/varingst/awesome-conky][awesome-conky]] to get an idea of how to better
integrate with AwesomeWM, then make some better widgets. :)

- conky-l1.lua
  #+begin_src lua
conky.config = {
    alignment = 'top_left',
    own_window_colour = '0C272D',
    background = false,
    border_width = 2,
    cpu_avg_samples = 2,
    default_color = 'D6685E',
    default_outline_color = '7D4C4E',
    default_shade_color = 'B19B75',
    double_buffer = false,
    draw_borders = false,
    draw_graph_borders = false,
    draw_outline = false,
    draw_shades = true,
    extra_newline = false,
    font = 'DejaVu Sans Mono:size=12',
    minimum_width = 500,
    minimum_height = 5,
    gap_x = 4,
    gap_y = -4,
    net_avg_samples = 2,
    no_buffers = true,
    own_window_hints = 'undecorated,sticky,skip_taskbar,skip_pager',
    out_to_console = false,
    out_to_ncurses = false,
    out_to_stderr = false,
    out_to_x = true,
    own_window = true,
    own_window_type = 'desktop',
    show_graph_range = false,
    show_graph_scale = false,
    stippled_borders = 0,
    update_interval = 4.0,
    uppercase = false,
    use_spacer = 'none',
    use_xft = true,
}

conky.text = [[
$nodename $kernel $machine
$hr
${color B19B75}Uptime:$color $uptime
${color B19B75}RAM Usage:$color $mem/$memmax - $memperc%
${membar 8}
$hr
${color EAB0B1}File systems:
 / $color${fs_used /}/${fs_size /}
${fs_bar 6 /}
Networking:
${color EAB0B1}Up:$color ${upspeed} ${color EAB0B1} - Down:$color ${downspeed}

${color grey}Frequency (in MHz):$color $freq
${color grey}Frequency (in GHz):$color $freq_g
$hr
]]
  #+end_src
- conky-l2.lua
  #+begin_src lua
conky.config = {
    alignment = 'bottom_left',
    background = false,
    own_window_colour = '36313B',
    border_width = 2,
    cpu_avg_samples = 2,
    default_color = 'F9F2D3',
    default_outline_color = 'white',
    default_shade_color = '7D4C4E',
    double_buffer = false,
    draw_borders = false,
    draw_graph_borders = false,
    draw_outline = false,
    draw_shades = true,
    extra_newline = false,
    font = 'DejaVu Sans Mono:size=12',
    minimum_height = 5,
    gap_x = 4,
    gap_y = 00,
    own_window_hints = 'undecorated,sticky,skip_taskbar,skip_pager',
    minimum_width = 500,
    no_buffers = true,
    out_to_console = false,
    out_to_ncurses = false,
    out_to_stderr = false,
    out_to_x = true,
    own_window = true,
    own_window_type = 'desktop',
    show_graph_range = false,
    show_graph_scale = false,
    stippled_borders = 0,
    update_interval = 4.0,
    uppercase = false,
    use_spacer = 'none',
    use_xft = true,
}

conky.text = [[
${color grey}CPU Usage:$color $cpu%
${color pink}${cpubar 8}$color
$hr
${color grey}Processes:$color $processes  ${color grey}Running:$color $running_processes
$hr
Name              PID     CPU%   MEM%
${color lightgrey} ${top name 1} ${top pid 1} ${top cpu 1} ${top mem 1}
${color lightgrey} ${top name 2} ${top pid 2} ${top cpu 2} ${top mem 2}
${color lightgrey} ${top name 3} ${top pid 3} ${top cpu 3} ${top mem 3}
${color lightgrey} ${top name 4} ${top pid 4} ${top cpu 4} ${top mem 4}
${color lightgrey} ${top name 5} ${top pid 5} ${top cpu 5} ${top mem 5}
${color lightgrey} ${top name 6} ${top pid 6} ${top cpu 6} ${top mem 6}
${color lightgrey} ${top name 7} ${top pid 7} ${top cpu 7} ${top mem 7}
${color lightgrey} ${top name 8} ${top pid 8} ${top cpu 8} ${top mem 8}
$hr
]]
  #+end_src

* Systemd-nspawn wizardry                                          :noexport:
:PROPERTIES:
:ID:       3e3fe9a7-579d-44c4-9d2f-cf690c274b97
:END:
* Packages
:PROPERTIES:
:ID:       01edd722-4161-4328-9f18-deef6f3f561d
:END:
Let's talk about /compression/ and /archiving/.

First thing's first, /compression/ != /archiving/. *Compression* is
the process of running an input through a /compression algorithm/,
resulting in an output size that is equivalent to or less than the
input. *Archiving* is the process of collecting multiple /files/ into
a single /archive file/, usually in a standard format (like
=.tar=). It is important to understand that when you generate a
directory from a file with an extension like =.tar.gz= or =.tar.zst=,
you are executing two very diffent processes - first a =decompress=
process (like =unzstd $file=), and then an =unarchive= process (like
=tar -xf $file=). These processes are often combined into a single
command (=tar --zstd -xf $file=), which can sometimes cause confusion.

** Zstd
*** API
*** Compression settings
*** Profiling
** Pack/Unpack
*** pack()
*** unpack()
** Mercurial Bundles
Mercurial Bundles are just compressed tar archives with extra
metadata.
** Blobs
* Mercurialology
:PROPERTIES:
:created:  <2021-08-14 Sat 23:49>
:ID:       ecc1f606-b6c2-4431-9bfe-adfe75ca3437
:END:
  I used to host all my code on [[https://github.com][GitHub]], but even before they were [[https://news.microsoft.com/announcement/microsoft-acquires-github/][acquired by Microsoft]]
  I found myself outgrowing the infrastructure they provide. I experimented with [[https://about.gitlab.com/][GitLab]]
  which I was familiar with from work, as well as [[https://sr.ht][sr.ht]]. Eventually I decided to start
  from scratch with Mercurial.

** Why Mercurial?
[[https://git-scm.com/][Git]] and [[https://www.mercurial-scm.org/][Mercurial]] are two different tools with the same job, it has just been my
experience that Mercurial does them a little bit better for my workflow, and I am able
to build things faster using it.

- Mercurial is designed to provide tools for /building/ a DVCS, and encourages you to
  expand your knowledge about the system to reap the benefits it provides. With Git I
  found myself often avoiding the implementation details in favor of quick-fixes and
  ugly scripts. On the other hand, I feel much more comfortable /designing/ a solution
  with the tools Mercurial provides.

- the Mercurial system has features such as immutable commits and branches, which can be
  quite dangerous. There are ways to 'fix' changes made by these commands, but they go
  against the grain of the rest of the system. Git on the other hand lets you seamlessly
  edit commits and close branches, which can be life-savers when Billy the Intern
  commits to master.

- Mercurial also has superior features for exporting native repository to different DVCS
  (Git, Darcs, SVN), making it more useful in scenarios where a repo needs to be shared
  with users or tools that are unfamiliar with the 'hg' command.

- Overall, the choice is a personal one. Over time I have felt less constrained, as if
  there were less rules to follow with Mercurial. This is a far-cry from my first
  experience with it, where I felt the complete opposite.

** Web Hosting
Hosting with vanilla Mercurial is quite similar to vanilla Git. =hg serve= is basically
the equivalent to =git instaweb=. Where they differ is in the out-of-box solutions - Git
has cgit, GitLab, Gitolite, git.sr.ht, etc. Mercurial has hg.sr.ht, and just recently
Heptapod, which is not production-ready.

My experience with self-hosting the sr.ht eco-system was far from a good one due to
conflicting dependencies, package manager incompatibility, and some classic PHP
craziness. The Heptapod docker container took eons just to build tests, so I just gave
up on that for now but will be on the look out for new developments with that
project. So what we're really left with is the built-in tools. Lucky for us, we have the
[[https://www.mercurial-scm.org/wiki/PublishingRepositories#hgweb][hgweb]] scripts at our disposal.

Here's the relevant docs covering all topics in this section. They are all must-reads if
you plan on exposing a Mercurial server to the public.

- [[https://www.mercurial-scm.org/wiki/PublishingRepositories][PublishingRepositories - Mercurial]]
- [[https://www.mercurial-scm.org/wiki/SecuringRepositories][SecuringRepositories - Mercurial]]
- [[https://www.mercurial-scm.org/wiki/AuthorizingUsers][AuthorizingUsers - Mercurial]]

- hgweb + wsgi + nginx \\
  The hgweb script is used for deployment of the server via CGI or WSGI. The WSGI setup
  is a bit more involved, but according to the docs:
  #+begin_quote
  (!) Much better performance can be achieved by using WSGI instead of CGI.
  #+end_quote

  This section covers the WSGI (pronounced /whis/-/gee/) setup, specifically for
  Nginx. The docs have better examples for Apache servers, so you do need to go off the
  beaten path to find just the right values to set in Nginx. The following setup worked
  for https://hg.rwest.io running Arch Linux.

  - dependencies \\
    - =uwsgi= and =uwsgi-plugin-python= are required for the hgweb.wsgi script.
    - =nginx= is used here, but...
    - =apache= package is needed if you want to use ~htpasswd~ while setting up HTTP
      Authentication. SSH auth only or public hosts don't need this.
  - /etc/uwsgi/hgweb.ini \\
    This is a UWSGI service configuration file - the =hgweb.wsgi= script needs to be
    located in the directory specified by =chdir=. If you are using systemd, try
    enabling the service with =systemctl enable uwsgi@hgweb.service=, and check the logs
    for any errors. The service calls the hgweb.wsgi script, which serves all repos
    configured via =hgweb.conf=.
    #+begin_example
    [uwsgi]
    master = true
    ; max-requests = 1000
    ; logto = {log file path}/hgweb-uwsgi.log
    uid = hgweb ; set process owner
    gid = hgweb
    stats = /run/uwsgi/stats.sock
    chmod-socket = 666
    cap = setgid,setuid
    ; https://www.mercurial-scm.org/wiki/PublishRepositoriesOnNginx
    plugins = python
    socket = /run/uwsgi/hgweb.sock
    chdir = /home/hgweb/hg
    wsgi-file = hgweb.wsgi
    ; https://stackoverflow.com/questions/15878176/uwsgi-invalid-request-block-size
    ; http://uwsgi-docs.readthedocs.io/en/latest/ThingsToKnow.html
    ; buffer-size = 65535
    #+end_example

  - hgweb.wsgi \\
    The config path must be a byte string, and an absolute path. This script needs to be
    in the same directory as =hgweb.conf=.
    #+begin_src python
    #!/usr/bin/env python3
    config = b"/home/hgweb/hgweb.conf"
    # Uncomment to send python tracebacks to the browser if an error occurs:
    #import cgitb; cgitb.enable()
    # enable demandloading to reduce startup time
    from mercurial import demandimport; demandimport.enable()
    from mercurial.hgweb import hgweb
    application = hgweb(config)
    #+end_src

  - hgweb.conf \\
    Mercurial web server configuration file. Setting staticurl to =/static= allows us to
    pass serving of static content to Nginx, which is faster and has better caching
    controls.
    #+begin_example
    [web]
    encoding = UTF-8
    baseurl = https://hg.rwest.io
    contact = some_dude
    templates = theme
    style = spartan
    logourl = https://rwest.io
    staticurl = /static
    descend = True
    collapse = True
    [paths]
    / = src/*
    #+end_example

  - /etc/nginx/sites-enabled/hg.conf \\
    Note that none of the extra uwsgi params from mercurial docs are used here, only the
    default uwsgi_params files provided by Nginx.
    #+begin_example
    server {
      server_name hg.rwest.io;
      listen 443 ssl;
      ssl_certificate fullchain.pem;
      ssl_certificate_key privkey.pem;
      ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;
      ssl_ciphers HIGH:!aNULL:!MD5;
      root /home/hgweb/hg;
      location / {
        limit_except GET HEAD {
          auth_basic "Mercurial userspace";
          auth_basic_user_file /home/hgweb/hg/hg.htpasswd;
        }
      include uwsgi_params;
      uwsgi_pass unix:/run/uwsgi/hgweb.sock;    
    }

    location /static {
      alias /home/hgweb/hg/static;
      expires 30d;
    }
  }
    #+end_example

- theme \\
  - screenshots
    #+caption: hgweb frontend
    #+attr_html: :width 600
    https://cdn.rwest.io/img/hgweb-frontend.png
    #+caption: hgweb graph view
    #+attr_html: :width 600
    https://cdn.rwest.io/img/hgweb-graph-frontend.png
    #+caption: hgweb rev view
    #+attr_html: :width 600
    https://cdn.rwest.io/img/hgweb-rev-frontend.png
    #+caption: hgweb file view
    #+attr_html: :width 600
    https://cdn.rwest.io/img/hgweb-file-frontend.png
    #+caption: hgweb browser view
    #+attr_html: :width 600
    https://cdn.rwest.io/img/hgweb-browse-frontend.png

** Bundles
Hg Bundles are a more powerful version of [[https://git-scm.com/docs/git-bundle/2.8.6][git bundles]] and come in two flavors:
Clonebundles and Pullbundles. They share a common format, support the =bundle= and
=unbundle= commands, but are also used to provision their own commands: =hg clone= and
=hg pull= respectively. Bundles are advertised via manifest files located in the =.hg=
directory of a repo, and support a variety of compression backends via the ~BUNDLESPEC~
value specified in manifest.
- Bundlespec
   - none-v2
   - gzip-v2
   - zstd-v2
   - stream-v2
- Manifests
  - clonebundles.manifest
  - pullbundles.manifest
  - manifest.json
- Hosting
  - https://pkg.rwest.io/hg/
** Scripts
- hg-pull.sh
  #+begin_src shell
#!/bin/bash
# store the current dir
CD=$(pwd)

echo "Pulling in latest changes for all local repositories..."

# Find all mercurial repositories, pull and update
for i in $(find . -name ".hg" | cut -c 3-); do
    echo "";
    echo $i;

    # We have to go to the .hg parent directory to call the pull command
    cd "$i";
    cd ..;
    # pull and update
    hg pull -u;
    # go back to the CUR_DIR
    cd $CD
done

echo "Done."

  #+end_src
- hg-bundle.sh
  #+begin_src shell
#!/bin/bash
# bundle a tar.zst archive of Mercurial repositories.

CD=$(pwd)
WD=$HOME/stash/tmp
OUT=$WD/bundle
SRC_PATH=$HOME/src
BUNDLE_NAME=bundle-$(date "+%Y%m%d").tar.zst

echo "Building $BUNDLE_NAME in $WD..."

mkdir -pv $OUT
rm -rf $OUT/*
rm -rf $WD/$BUNDLE_NAME

cd $SRC_PATH

# Find all mercurial repositories, create bundles and dump them to $OUT dir
for i in $(find . -name ".hg" | cut -c 3-); do
    echo "";
    echo $i;

    cd "$i";
    cd ..;
    hg bundle -a -t gzip-v2 $OUT/$(basename $(hg root)).hg.gz;
    hg bundle -a -t zstd-v2 $OUT/$(basename $(hg root)).hg.zst;
    hg bundle -a -t none-v2 $OUT/$(basename $(hg root)).hg;
    hg debugcreatestreamclonebundle $OUT/$(basename $(hg root)).hg.stream;
    echo "... Done.";
    cd $SRC_PATH
done

cd $WD
# this will take a while with ultra mode
tar -I 'zstd --ultra -22' -cf $BUNDLE_NAME bundle/

echo "Done."
  #+end_src
- hg-unbundle.sh
  #+begin_src shell
#!/bin/sh
# unbundle a tar.zst archive of Mercurial repositories.
# this will generate a directory name 'bundle' in '~/pkg/hg/'
WD=$HOME/stash/tmp
BUNDLE_NAME=bundle-$(date "+%Y%m%d")
PKG_DIR=$HOME/pkg/hg
echo "unbundling $i to $PKG_DIR/bundle"
# the zstd options for tar no work for me, decompress archive (this should be MacOS only, maybe Win. need to add checks)
unzstd $WD/$BUNDLE_NAME.tar.zst
tar -xvf $WD/$BUNDLE_NAME.tar -C $PKG_DIR
rm -rf $WD/$BUNDLE_NAME.tar.zst $WD/$BUNDLE_NAME.tar
echo "Done."
  #+end_src
** Further Reading
- [[https://blog.nrwl.io/misconceptions-about-monorepos-monorepo-monolith-df1250d4b03c][Misconceptions about Monorepos: Monorepo != Monolith]] - Victor Savkin 2019
- [[https://research.google/pubs/pub45424/][Why Google Stores Billions of Lines of Code in a Single Repository]] - Josh Levenberg, 2016

* stupid-simple-log-file
  :PROPERTIES:
  :created: <2021-07-07 Wed 19:08>
  :ID:       65728254-9ebe-40ff-a403-04207dcb0125
  :END:
 I have a directory called 'log' that contains org files, with one file for each day and
 a filename of the form =YYYYMMDD.org=.

 On the often occasion that I'm up past 00:00 on the system clock, I usually just use
 "yesterday's" =org-log-file= until I find a good time to take a break, at which point I
 can restart my emacs session OR just execute the =log-file= function to open the fresh
 log for the day.
 
 #+begin_src emacs-lisp
(defvar org-dir "~/stash/org/")
(defvar log-file-format (format-time-string "%Y%m%d.org"))
(defvar org-log-file (join-paths org-dir "log/" log-file-format))

;; if buffer-file-name is non-nil, open today's log-file
(setq initial-buffer-choice
  (lambda ()
    (if (buffer-file-name)
      (current-buffer) ;; leave as-is
      (find-file org-log-file))))

;; open today's log-file
(defun log-file ()
  "Open today's log file in the current buffer."
  (interactive)
  (find-file org-log-file))
 #+end_src
